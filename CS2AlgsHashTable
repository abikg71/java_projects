//HOME WORK PROBLEMS FROM TEXTBOOK
// The following code is writteN to check the given instruction on the Algs4ed
//Chapter 3, HW #5 
// Abinet Kenore, MW 06:00 T0 07:50 CS 2050 Fall 2016,
//Java Program to Implement Hash Tables Chaining with Binary Trees
 import java.util.*;
import java.io.*;
import java.lang.*;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;
import java.util.Scanner;
//

/* Node for Binary Tree */
class BTNode
{
    BTNode left, right, parent;
  int data;
   String region,state;
     boolean dupDMACode;
     int treeReBalD,numTreeInsertD,height;
    /* Constructor */
    public BTNode(int x, String rgn, String states, boolean dupDMACd,
                int treeBalD, int nmTreeInsertD )
     {
         left = null;
         right = null;
         parent = null;
         data = x;
         region = rgn;
         state = states;
         dupDMACode = dupDMACd;
         treeReBalD = treeBalD;
         numTreeInsertD = nmTreeInsertD;
         height = 0;
     }

/* Class HashTableChainingBinaryTree */
class HashTableChainingBinaryTree
{
    private BTNode[] table;
    private int size ;
 
    /* Constructor */
    public HashTableChainingBinaryTree(int tableSize)
    {
        table = new BTNode[ nextPrime(tableSize) ];
        size = 0;
    }
    /* Function to check if hash table is empty */
    public boolean isEmpty()
    {
        return size == 0;
    }
    /* Function to clear hash table */
    public void makeEmpty()
    {
        int l = table.length;
        table = new BTNode[l];
        size = 0;
    }
    /* Function to get size */
    public int getSize()
    {
        return size;
    }
    /* Function to insert an element */
       /* Function to insert data */
  public BTNodeR insertR(int x, String regionR, int dataR, String stateR, 
               boolean dupRegion, int treeReBalDR, int numTreeInsertDR)
     {
         BTNodeR yR = new SBBSTNodeR("",0,"", false, 0,0);
         rootR = insertR(regionR, dataR, stateR, dupRegion, treeReBalDR, 
                           numTreeInsertDR, rootR, yR);
         return rootR;
     }
     /* Function to get height of node */
     private int heightR(SBBSTNodeR tR )
     {
         return tR == null ? -1 : tR.heightR;
     }
     /* Function to max of left/right node */
     private int maxR(int lhsR, int rhsR)
     {
         return lhsR > rhsR ? lhsR : rhsR;
     }
     /* Given a non-empty hash table  search tree, return the
       node with minimum key value found in that tree.
       Note that the entire tree does not need to be
       searched. */
    private SBBSTNodeR minValueNodeR(SBBSTNodeR nodeR)
    {
        SBBSTNodeR currentR = nodeR;
 
        /* loop down to find the leftmost leaf */
        while (currentR.leftR != null)
           currentR = currentR.leftR;
 
        return currentR;
    }

     /* Function to insert data recursively */
    
public SBBSTNodeR insertR(String rgon, int xR, String stt, boolean dupRg,
               int tBalDR, int nTreeInDR, SBBSTNodeR tR, SBBSTNodeR zR)
     // Pair<String, String>
     {
         if (tR == null)
         {
             tR = new SBBSTNodeR(rgon, xR, stt, dupRg, tBalDR, nTreeInDR);
             tR.numTreeInsertDR = tR.numTreeInsertDR + 1;
             tR.parentR = zR;
         }
         else if ((rgon.compareTo(tR.regionR) < 0) && (!(tR.dupRegion)))
         {
      tR.leftR = insertR( rgon, xR, stt, dupRg, tBalDR, nTreeInDR, tR.leftR, zR );
             if (heightR( tR.leftR ) - heightR( tR.rightR ) == 2)
                 if (rgon.compareTo(tR.leftR.regionR) < 0)
                 {
                     tR = rotateWithLeftChildR( tR );
                     tR.treeReBalDR = tR.treeReBalDR + 1;
                 }
                 else
                 {
                     tR = doubleWithLeftChildR( tR );
                     tR.treeReBalDR = tR.treeReBalDR + 1;
                 }
         }
         else if ((rgon.compareTo(tR.regionR) > 0) && (!(tR.dupRegion)))
         {
             tR.rightR = insertR( rgon, xR, stt, dupRg, tBalDR, nTreeInDR,
                     tR.rightR, tR);
                     
             if (heightR( tR.rightR ) - heightR( tR.leftR ) == 2)
                 if (rgon.compareTo(tR.rightR.regionR) > 0)
                 {
                     tR = rotateWithRightChildR( tR );
                     tR.treeReBalDR = tR.treeReBalDR + 1;
                 }
                 else
                 {
                     tR = doubleWithRightChildR( tR );
                     tR.treeReBalDR = tR.treeReBalDR + 1;
                 }
         }
         else
         {
            
         }

         tR.heightR = maxR( heightR( tR.leftR ), heightR( tR.rightR ) ) + 1;
         return tR;
     }
    /* Function to remove an element */
    public void remove(int val)
    {
        int pos = myhash(val);        
        BTNode root = table[pos];
        try
        {
            root = delete(root, val);    
            size--;
        }
        catch (Exception e)
        {
            System.out.println("\nElement not present\n");        
        }        
        table[pos] = root;        
    }
    /* Function to remove an element */
  public void delete(int x, int treeReBalD, int numTreeInsertD)
    {
      root = delete(root, x, root.treeReBalD, root.numTreeInsertD);
    }
    
private BTNode delete(BTNode root,int x,int treeReBalD,int numTreeInsertD)
    {
        if (root == null)
            return root;
        
        // If the key to be deleted is smaller than
        // the root's key, then it lies in left subtree
        if (x < root.data)
        {
            // treeReBalD = root.left.treeReBalD;
            // numTreeInsertD = root.left.numTreeInsertD;
       root.left = delete(root.left, x, treeReBalD, numTreeInsertD);
        }
        // If the key to be deleted is greater than the
        // root's key, then it lies in right subtree
        else if (x > root.data)
        {
            // treeReBalD = root.right.treeReBalD;
            // numTreeInsertD = root.right.numTreeInsertD;
         root.right = delete(root.right, x, treeReBalD, numTreeInsertD);
        }
        else
        {
           if (root.right ==  null) 
               return root.left;
           if (root.left == null)
               return root.right;
               
 BTNode temp = root;

     root.parent.treeReBalD = root.parent.treeReBalD + root.treeReBalD;
     root.parent.numTreeInsertD = root.parent.numTreeInsertD + root.numTreeInsertD;      
     root = min(temp.right);
     root.right = deleteMin(temp.right);
     root.left = temp.left;
        }
        
        // If the tree had only one node then return
        if (root == null)
            return root;
 
        // STEP 2: UPDATE HEIGHT OF THE CURRENT NODE
        root.height = max(height(root.left), height(root.right)) + 1;
 
        // STEP 3: GET THE BALANCE FACTOR OF THIS NODE (to check whether
        //  this node became unbalanced)
        int balance = getBalance(root);           
 
        // If this node becomes unbalanced, then there are 4 cases
        // Left Left Case
        if (balance > 1 && getBalance(root.left) >= 0)
        {
            root.treeReBalD = root.treeReBalD + 1;
            return rightRotate(root);
        }
        // Left Right Case
        if (balance > 1 && getBalance(root.left) < 0)
        {
            root.left.treeReBalD = root.left.treeReBalD + 1;
            root.left = leftRotate(root.left);
            root.treeReBalD = root.treeReBalD + 1;
            return rightRotate(root);
        }
 
        // Right Right Case
        if (balance < -1 && getBalance(root.right) <= 0)
        {
            root.treeReBalD = root.treeReBalD + 1;
            return leftRotate(root);
        }
        // Right Left Case
        if (balance < -1 && getBalance(root.right) > 0)
        {
            root.right.treeReBalD = root.right.treeReBalD + 1;
            root.right = rightRotate(root.right);
            root.treeReBalD = root.treeReBalD + 1;
            return leftRotate(root);
        }
 
        return root;
    }    

  private BTNode deleteNode(int x, int treeReBalD, BTNode root)
    {
        // STEP 1: PERFORM STANDARD  HASH DELETE
        if (root == null)
            return root;
        
        if (x < root.data)
            root.left = deleteNode(x, treeReBalD, root.left);
 
        // If the key to be deleted is smaller than
        // the root's key, then it lies in left subtree
        if (x < root.data)
            root.left = deleteNode(x, treeReBalD, root.left);
 
        // If the key to be deleted is greater than the
        // root's key, then it lies in right subtree
        else if (x > root.data)
            root.right = deleteNode(x, treeReBalD, root.right);
 
        // if key is same as root's key, then this is the node
        // to be deleted
        else
        {
 
            // node with only one child or no child
            if ((root.left == null) || (root.right == null))
            {
                BTNode temp = null;
                if (temp == root.left)
                    temp = root.right;
                else
                    temp = root.left;
 
                // No child case
                if (temp == null)
                {
                    temp = root;
                    root = null;
                }
                else   // One child case
                    root = temp; // Copy the contents of
                                 // the non-empty child
            }
            else
            {
 
         // node with two children: Get the inorder
         // successor (smallest in the right subtree)
          SBBSTNode temp = minValueNode(root.right);
            /// SBBSTNode temp = minValueNode(root.left);
 
            // Copy the inorder successor's data to this node
            root.data = temp.data;
 
            // Delete the inorder successor
         root.right = deleteNode(temp.data, treeReBalD, root.right);
         // root.left = deleteNode(temp.data, treeReBalD, root.left);
            }
        }
        
        // If the tree had only one node then return
        if (root == null)
            return root;
 
        // STEP 2: UPDATE HEIGHT OF THE CURRENT NODE
        root.height = max(height(root.left), height(root.right)) + 1;
 
        // STEP 3: GET THE BALANCE FACTOR OF THIS NODE (to check whether
        //  this node became unbalanced)
        int balance = getBalance(root);           
 
        // If this node becomes unbalanced, then there are 4 cases
        // Left Left Case
        if (balance > 1 && getBalance(root.left) >= 0)
            return rightRotate(root);
 
        // Left Right Case
        if (balance > 1 && getBalance(root.left) < 0)
        {
            root.left = leftRotate(root.left);
            return rightRotate(root);
        }
 
        // Right Right Case
        if (balance < -1 && getBalance(root.right) <= 0)
            return leftRotate(root);
 
        // Right Left Case
        if (balance < -1 && getBalance(root.right) > 0)
        {
            root.right = rightRotate(root.right);
            return leftRotate(root);
        }
 
        return root;
    }    
     
 }
    /* Function myhash */
    private int myhash(Integer x )
    {
        int hashVal = x.hashCode( );
        hashVal %= table.length;
        if (hashVal < 0)
            hashVal += table.length;
        return hashVal;
    }
    /* Function to generate next prime number >= n */
    private static int nextPrime( int n )
    {
        if (n % 2 == 0)
            n++;
        for ( ; !isPrime( n ); n += 2);
 
        return n;
    }
    /* Function to check if given number is prime */
    private static boolean isPrime( int n )
    {
        if (n == 2 || n == 3)
            return true;
        if (n == 1 || n % 2 == 0)
            return false;
        for (int i = 3; i * i <= n; i += 2)
            if (n % i == 0)
                return false;
        return true;
    }
    /* printing hash table */
    public void printHashTable ()
    {
        System.out.println();
        for (int i = 0; i < table.length; i++)
        {
            System.out.print ("Bucket " + i + ":  ");            
            inorder(table[i]);
            System.out.println();
        }
    }  
    /* inorder traversal */
    private void inorder(BTNode r)
    {
        if (r != null)
        {
            inorder(r.left);
            System.out.print(r.data +" ");
            inorder(r.right);
        }
    }     
}
 
/* Class HashTableChainingBinaryTreeTest */
public class HashTableChainingBinaryTreeTest
{ 
    public static void main(String[] args) 
    {
        Scanner scan = new Scanner(System.in);
        System.out.println("Hash Table Test\n\n");
        System.out.println("Enter size");
        /* Make object of HashTableChainingBinaryTree  */
        HashTableChainingBinaryTree htcbt = new HashTableChainingBinaryTree(scan.nextInt() );
 
        char ch;
        /*  Perform HashTableChainingBinaryTree operations  */
        do     
        {
            System.out.println("\nHash Table Operations\n");
            System.out.println("1. insert ");
            System.out.println("2. remove"); 
            System.out.println("3. clear");
            System.out.println("4. size"); 
            System.out.println("5. check empty");
 
            int choice = scan.nextInt();            
            switch (choice)  
            {  
            case 1 : 
                System.out.println("Enter integer element to insert");
                htcbt.insert( scan.nextInt() ); 
                break;                          
            case 2 :                 
                System.out.println("Enter integer element to delete");
                htcbt.remove( scan.nextInt() ); 
                break;                        
            case 3 : 
                htcbt.makeEmpty();
                System.out.println("Hash Table Cleared\n");
                break;
            case 4 : 
                System.out.println("Size = "+ htcbt.getSize() );
                break; 
            case 5 : 
                System.out.println("Empty status = "+ htcbt.isEmpty() );
                break;        
            default : 
                System.out.println("Wrong Entry \n ");
                break;    
            }
            /* Display hash table */ 
            htcbt.printHashTable();    
 
            System.out.println("\nDo you want to continue (Type y or n) \n");
            ch = scan.next().charAt(0);                        
        } while (ch == 'Y'|| ch == 'y');   
    }
}
public static int readFile(String fileNm, PreorderBTNode sbbst, PreorderBTNodeR sbbst2)
    {   
      BTNode sbbst4 = new BTNode();
      BTNodeR sbbst1 = new BTNode(); 
      int rowsCols = 100;
      String[] multDMA = new String[rowsCols + rowsCols + rowsCols];   
      String[] multRegion = new String[rowsCols + rowsCols + rowsCols];
      int indxDMA = 0;
      int indxRegion = 0;
      int tempIndx = 0;
      String tempInt;
      long estimatedTime = 0;
      int regionLenMax = 0;
      int regionLen = 0;
      int numInsertDT = 0;
      int numtreeReBalDT = 0;
      int recCount = 0;

      String s = "";
      String cvsSplitBy = ",";
      String line = " ";
    // 
    
     File file = new File(fileNm);
      try {
         long startTime = System.nanoTime(); 
         Scanner fileScan = new Scanner(file);
         do 
          {
           line = fileScan.nextLine();	// get the first line of the file
                // process the current line by adding it to the array
           String[] piecesF = line.split(cvsSplitBy);
           try {
            int dmacodeF = Integer.parseInt(piecesF[0]);
            boolean duplDMACode = false;
            boolean dupRegionVal = false;
            regionLen = (piecesF[1].length());
              if (regionLenMax < regionLen)
                  regionLenMax = regionLen;
                 recCount = recCount + 1;
                 sbbst8 = sbbst.insert(dmacodeF, piecesF[1], piecesF[2],
                 duplDMACode, numtreeReBalDT, numInsertDT);
                 indxDMA ++;
                    
                numInsertDT = 0;
                numtreeReBalDT = 0;
                sbbst9 = sbbst2.insertR(piecesF[1], dmacodeF, piecesF[2],
                dupRegionVal, numtreeReBalDT, numInsertDT);   
                        
                } catch (Exception e)
                {     
                 // dma code,region,state
                 System.out.println("First line of input is bad data or Headings");
                 System.out.println("Will read second record to see if valid data");
                }
       
                // get the next line until the entire file has been read
       } while (fileScan.hasNextLine());
         long stopTime = System.nanoTime();
         estimatedTime = System.nanoTime() - startTime;
         System.out.printf("\nCPU Time is combination of DMA Code and Region Key Order \n");
         System.out.printf("CPU Time is %,d \n", estimatedTime);
         System.out.printf("\nNumber of Records read %,d \n", recCount);

        fileScan.close();
        } catch (Exception e) {
         System.out.println("Exception reading file" + fileNm);
         e.printStackTrace();
        }

        return regionLenMax;
    }
}
